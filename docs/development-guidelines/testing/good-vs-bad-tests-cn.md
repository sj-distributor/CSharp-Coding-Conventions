
# 好的 vs. 坏的 Tests

What makes a good test good, and a bad test bad?

### **要** 无论测试通过还是失败，都要编写提供有用信息的测试
当测试通过时，成功需要告诉我们系统的一些有价值的东西。当一个测试失败时，这个失败需要告诉我们关于这个有缺陷的系统的一些有价值的东西。测试失败应该为开发人员提供测试名称和异常详细信息中的重要线索。如果很难确定测试失败的原因，那么它还没有编写好。

### **要** 一定要编写测试，让你有信心做出改变
健康的测试套件使开发人员能够自信地对系统进行更改。测试套件提供覆盖范围，以便可以立即检测到更改的负面后果。

### **要** 写清楚、简明、简洁的测试
出于同样的原因，我们对待测试代码和部署代码一样认真。在质量方面，测试遵循我们所有的常规代码实践。

### **要** 每个测试做一个逻辑断言
有一条共同的规则说，每个测试应该只有一个断言。我们并不是从字面上理解：每个测试可能有多个“断言”语句（或等效语句），但所有这些断言都应该测试一个逻辑结果。
例如：如果您正在测试一个包含多个属性的结果对象，则可以对每个属性进行断言，以便断言整个结果与预期的逻辑状态匹配。

### **要** 编写为系统增加价值的测试
我们测试系统中具有关键业务逻辑或核心功能的方法和类。测试这些方法为项目增加了最大的价值，因为项目核心中的bug如果在交付之前没有被发现，将会是最严重的。

相反，我们不测试琐碎的方法。对琐碎方法的测试只会增加混乱、额外的测试运行时间，对项目没有价值。
例如，我们不会为这个方法编写测试，尽管它的效果可能会出现在更复杂的方法的更有用的测试中：
```csharp
string Concat(string a, string b) { return a + b; }
```

### **要** 清楚地命名测试，因为这是诊断测试失败时的第一条线索
测试是以它们所断言的东西命名的（下面有更多细节），因此我们可以一目了然地看到它们失败的原因。

### **要** 编写一致执行的测试
通过的测试应在每次执行时通过。失败的测试应该失败，并且每次执行时都以同样的方式失败。

### **要** 编写独立的测试
无论一次运行中执行了哪些测试，也不管它们的运行顺序如何，测试都应该是一致的。

### **避免** 一次测试太多东西
一次测试太多东西会导致测试方法冗长且难以阅读。这也使我们更难看到我们是否已经获得了完整的测试覆盖，并且正在正确地测试边缘案例。

### **避免** 当被测系统发生重大变化时，编写保持绿色的测试
如果您可以更改测试中的系统，从而中断测试，但它们仍然是绿色的，则表明您的测试存在严重问题。这类测试很可能是测试琐碎的事情，没有做出好的断言，或者没有给出有效的测试数据。

### **要** 为了 “happy path” 和 边界情况 写测试
如果您只在一切正常运行时测试代码的结果，那么您只测试了一半代码。期待意外的结果——在代码失败时测试代码的行为。
将“happy path”测试放在文件中的边缘用例测试之前，这样当从上到下阅读测试类时，您可以像阅读需求文档时一样了解该特性：“通常会这样，但我们也会涵盖这些相关的边缘用例“。

### **避免** 测试方法中的显式循环和条件逻辑
我们编写测试的原因之一是，使用有缺陷的逻辑编写生产代码太容易了。当我们的测试和被测系统一样复杂时，我们可以很容易地编写不正确但仍然通过的测试，给我们一种错误的安全感。
有时，循环/条件在测试中是不可避免的，或者提供了足够的简洁性，使得它们变得有价值，但我们应该尽可能强调测试中的直截了当的代码。

### **不要** 编写给你错误的安全感的测试

好的测试在通过时告诉我们有用的信息，在失败时告诉我们有益的信息。
一个糟糕的测试可能会通过，但却没有告诉我们什么价值。它可能在没有断言的情况下使用某个特性，或者在遗漏重要断言的同时做出不相关的断言，这样会失去测试的价值。

### **不要** 编写表面上满足任意代码覆盖率指标的测试
正如我们之前所讨论的，我们不喜欢琐碎的测试，因为它们只会增加混乱。通常，代码覆盖率指标是一个任意的目标，最终会鼓励糟糕的测试。我们关心的是质量而不是数量。

### **要** 异步系统编写异步测试
所有.NET测试框架都允许将测试方法声明为异步。当测试调用异步系统时，测试方法自然也应该是异步的。相反，不要用Task阻塞异步系统使用Task.Wait()。Task.Result或Task.GetAwaiter（）.GetResult（）。相反，就像我们在MVC中处理控制器操作一样，只需允许周围的测试框架适当地处理返回的Task。

### **要** 使用支持异步设置的测试框架
使用xUnit和Fixie，测试类构造函数是在每个测试用例执行之前放置要执行的公共设置步骤的默认位置。
然而，由于我们的大多数集成测试设置将涉及Mediator `Send` 或其他`async`调用，所以构造函数设置是不可能的。构造函数中的`async`调用甚至无法编译！


使用xUnit，您可以依赖 [IAsyncLifetime](https://stackoverflow.com/a/45906269)

使用Fixie, 我们可以创建字的 [own convention](https://github.com/fixie/fixie/wiki#putting-it-all-together) 即任何名为`SetUp`的测试方法都应该被视为设置方法，而不是被视为测试。
